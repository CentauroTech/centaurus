import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentTeamMember } from './useCurrentTeamMember';
import { GuestCompletedTask } from './useGuestCompletedHistory';

export type InvoiceStatus = 'draft' | 'submitted' | 'approved' | 'rejected' | 'paid';

export interface InvoiceItem {
  id: string;
  invoiceId: string;
  completedTaskId?: string;
  description: string;
  workOrderNumber?: string;
  phase?: string;
  rolePerformed?: string;
  runtime?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  createdAt: string;
}

export interface Invoice {
  id: string;
  invoiceNumber: string;
  teamMemberId: string;
  teamMemberName?: string;
  status: InvoiceStatus;
  
  // Billing details
  billingName: string;
  billingAddress?: string;
  billingCity?: string;
  billingCountry?: string;
  billingTaxId?: string;
  billingBankName?: string;
  billingBankAccount?: string;
  billingBankRouting?: string;
  billingNotes?: string;
  
  // Payment terms
  invoiceDate: string;
  dueDate?: string;
  paymentInstructions?: string;
  
  // Totals
  subtotal: number;
  taxRate: number;
  taxAmount: number;
  totalAmount: number;
  currency: string;
  
  // Admin
  rejectionReason?: string;
  approvedById?: string;
  approvedAt?: string;
  
  createdAt: string;
  updatedAt: string;
  
  // Items
  items?: InvoiceItem[];
}

export interface CreateInvoiceData {
  billingName: string;
  billingAddress?: string;
  billingCity?: string;
  billingCountry?: string;
  billingTaxId?: string;
  billingBankName?: string;
  billingBankAccount?: string;
  billingBankRouting?: string;
  billingNotes?: string;
  dueDate?: string;
  paymentInstructions?: string;
  taxRate?: number;
  items: {
    completedTaskId?: string;
    description: string;
    workOrderNumber?: string;
    phase?: string;
    rolePerformed?: string;
    runtime?: string;
    quantity: number;
    unitPrice: number;
  }[];
}

// Guest hooks - view and manage own invoices
export function useMyInvoices() {
  const { data: currentMember } = useCurrentTeamMember();

  return useQuery({
    queryKey: ['my-invoices', currentMember?.id],
    queryFn: async (): Promise<Invoice[]> => {
      if (!currentMember?.id) return [];

      const { data, error } = await supabase
        .from('invoices')
        .select('*')
        .eq('team_member_id', currentMember.id)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return (data || []).map(mapInvoice);
    },
    enabled: !!currentMember?.id,
  });
}

export function useInvoice(invoiceId: string) {
  return useQuery({
    queryKey: ['invoice', invoiceId],
    queryFn: async (): Promise<Invoice | null> => {
      if (!invoiceId) return null;

      const { data: invoice, error } = await supabase
        .from('invoices')
        .select('*')
        .eq('id', invoiceId)
        .single();

      if (error) throw error;
      if (!invoice) return null;

      // Fetch items
      const { data: items, error: itemsError } = await supabase
        .from('invoice_items')
        .select('*')
        .eq('invoice_id', invoiceId)
        .order('created_at');

      if (itemsError) throw itemsError;

      return {
        ...mapInvoice(invoice),
        items: (items || []).map(mapInvoiceItem),
      };
    },
    enabled: !!invoiceId,
  });
}

export function useCreateInvoice() {
  const queryClient = useQueryClient();
  const { data: currentMember } = useCurrentTeamMember();

  return useMutation({
    mutationFn: async (data: CreateInvoiceData) => {
      if (!currentMember?.id) throw new Error('Not authenticated');

      // Calculate totals
      const subtotal = data.items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
      const taxRate = data.taxRate || 0;
      const taxAmount = subtotal * (taxRate / 100);
      const totalAmount = subtotal + taxAmount;

      // Create invoice
      const { data: invoice, error } = await supabase
        .from('invoices')
        .insert({
          team_member_id: currentMember.id,
          invoice_number: '', // Will be generated by trigger
          status: 'draft',
          billing_name: data.billingName,
          billing_address: data.billingAddress,
          billing_city: data.billingCity,
          billing_country: data.billingCountry,
          billing_tax_id: data.billingTaxId,
          billing_bank_name: data.billingBankName,
          billing_bank_account: data.billingBankAccount,
          billing_bank_routing: data.billingBankRouting,
          billing_notes: data.billingNotes,
          due_date: data.dueDate,
          payment_instructions: data.paymentInstructions,
          subtotal,
          tax_rate: taxRate,
          tax_amount: taxAmount,
          total_amount: totalAmount,
        })
        .select()
        .single();

      if (error) throw error;

      // Create invoice items
      if (data.items.length > 0) {
        const itemsToInsert = data.items.map(item => ({
          invoice_id: invoice.id,
          completed_task_id: item.completedTaskId || null,
          description: item.description,
          work_order_number: item.workOrderNumber,
          phase: item.phase,
          role_performed: item.rolePerformed,
          runtime: item.runtime,
          quantity: item.quantity,
          unit_price: item.unitPrice,
          total_price: item.quantity * item.unitPrice,
        }));

        const { error: itemsError } = await supabase
          .from('invoice_items')
          .insert(itemsToInsert);

        if (itemsError) throw itemsError;
      }

      return invoice;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

export function useUpdateInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ invoiceId, data }: { invoiceId: string; data: Partial<CreateInvoiceData> }) => {
      // Calculate totals if items are provided
      let updates: Record<string, any> = {};
      
      if (data.billingName !== undefined) updates.billing_name = data.billingName;
      if (data.billingAddress !== undefined) updates.billing_address = data.billingAddress;
      if (data.billingCity !== undefined) updates.billing_city = data.billingCity;
      if (data.billingCountry !== undefined) updates.billing_country = data.billingCountry;
      if (data.billingTaxId !== undefined) updates.billing_tax_id = data.billingTaxId;
      if (data.billingBankName !== undefined) updates.billing_bank_name = data.billingBankName;
      if (data.billingBankAccount !== undefined) updates.billing_bank_account = data.billingBankAccount;
      if (data.billingBankRouting !== undefined) updates.billing_bank_routing = data.billingBankRouting;
      if (data.billingNotes !== undefined) updates.billing_notes = data.billingNotes;
      if (data.dueDate !== undefined) updates.due_date = data.dueDate;
      if (data.paymentInstructions !== undefined) updates.payment_instructions = data.paymentInstructions;
      if (data.taxRate !== undefined) updates.tax_rate = data.taxRate;

      if (data.items) {
        const subtotal = data.items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
        const taxRate = data.taxRate || 0;
        const taxAmount = subtotal * (taxRate / 100);
        updates.subtotal = subtotal;
        updates.tax_amount = taxAmount;
        updates.total_amount = subtotal + taxAmount;

        // Delete existing items and re-create
        await supabase.from('invoice_items').delete().eq('invoice_id', invoiceId);

        const itemsToInsert = data.items.map(item => ({
          invoice_id: invoiceId,
          completed_task_id: item.completedTaskId || null,
          description: item.description,
          work_order_number: item.workOrderNumber,
          phase: item.phase,
          role_performed: item.rolePerformed,
          runtime: item.runtime,
          quantity: item.quantity,
          unit_price: item.unitPrice,
          total_price: item.quantity * item.unitPrice,
        }));

        if (itemsToInsert.length > 0) {
          await supabase.from('invoice_items').insert(itemsToInsert);
        }
      }

      const { data: invoice, error } = await supabase
        .from('invoices')
        .update(updates)
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;
      return invoice;
    },
    onSuccess: (_, { invoiceId }) => {
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
    },
  });
}

export function useSubmitInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      const { data, error } = await supabase
        .from('invoices')
        .update({ status: 'submitted' })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (_, invoiceId) => {
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
    },
  });
}

export function useDeleteInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      const { error } = await supabase
        .from('invoices')
        .delete()
        .eq('id', invoiceId);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

// Admin hooks - view all invoices and update status
export function useAllInvoices() {
  return useQuery({
    queryKey: ['all-invoices'],
    queryFn: async (): Promise<Invoice[]> => {
      const { data, error } = await supabase
        .from('invoices')
        .select(`
          *,
          team_members!invoices_team_member_id_fkey (name)
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return (data || []).map(row => ({
        ...mapInvoice(row),
        teamMemberName: (row as any).team_members?.name,
      }));
    },
  });
}

export function useApproveInvoice() {
  const queryClient = useQueryClient();
  const { data: currentMember } = useCurrentTeamMember();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      if (!currentMember?.id) throw new Error('Not authenticated');

      const { data, error } = await supabase
        .from('invoices')
        .update({
          status: 'approved',
          approved_by_id: currentMember.id,
          approved_at: new Date().toISOString(),
          rejection_reason: null,
        })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;

      // Create notification for the invoice owner
      const invoiceData = data as any;
      if (invoiceData.team_member_id) {
        await supabase.rpc('create_notification', {
          p_user_id: invoiceData.team_member_id,
          p_type: 'invoice_approved',
          p_title: `Invoice ${invoiceData.invoice_number} Approved`,
          p_message: 'Your invoice has been approved and is ready for payment.',
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      return data;
    },
    onSuccess: (_, invoiceId) => {
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

export function useRejectInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ invoiceId, reason }: { invoiceId: string; reason: string }) => {
      const { data, error } = await supabase
        .from('invoices')
        .update({
          status: 'rejected',
          rejection_reason: reason,
        })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (_, { invoiceId }) => {
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

export function useMarkInvoicePaid() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      const { data, error } = await supabase
        .from('invoices')
        .update({ status: 'paid' })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (_, invoiceId) => {
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

// Helper functions
function mapInvoice(row: any): Invoice {
  return {
    id: row.id,
    invoiceNumber: row.invoice_number,
    teamMemberId: row.team_member_id,
    status: row.status,
    billingName: row.billing_name,
    billingAddress: row.billing_address,
    billingCity: row.billing_city,
    billingCountry: row.billing_country,
    billingTaxId: row.billing_tax_id,
    billingBankName: row.billing_bank_name,
    billingBankAccount: row.billing_bank_account,
    billingBankRouting: row.billing_bank_routing,
    billingNotes: row.billing_notes,
    invoiceDate: row.invoice_date,
    dueDate: row.due_date,
    paymentInstructions: row.payment_instructions,
    subtotal: parseFloat(row.subtotal) || 0,
    taxRate: parseFloat(row.tax_rate) || 0,
    taxAmount: parseFloat(row.tax_amount) || 0,
    totalAmount: parseFloat(row.total_amount) || 0,
    currency: row.currency || 'USD',
    rejectionReason: row.rejection_reason,
    approvedById: row.approved_by_id,
    approvedAt: row.approved_at,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

function mapInvoiceItem(row: any): InvoiceItem {
  return {
    id: row.id,
    invoiceId: row.invoice_id,
    completedTaskId: row.completed_task_id,
    description: row.description,
    workOrderNumber: row.work_order_number,
    phase: row.phase,
    rolePerformed: row.role_performed,
    runtime: row.runtime,
    quantity: parseFloat(row.quantity) || 1,
    unitPrice: parseFloat(row.unit_price) || 0,
    totalPrice: parseFloat(row.total_price) || 0,
    createdAt: row.created_at,
  };
}

// Helper to create invoice items from completed tasks
export function createItemsFromCompletedTasks(tasks: GuestCompletedTask[], defaultRate: number = 0): CreateInvoiceData['items'] {
  return tasks.map(task => ({
    completedTaskId: task.id,
    description: `${task.taskName}${task.tituloAprobadoEspanol ? ` - ${task.tituloAprobadoEspanol}` : ''}`,
    workOrderNumber: task.workOrderNumber,
    phase: task.phase,
    rolePerformed: task.rolePerformed,
    runtime: task.lockedRuntime,
    quantity: 1,
    unitPrice: defaultRate,
  }));
}
