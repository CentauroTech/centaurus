import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useCurrentTeamMember } from './useCurrentTeamMember';
import { GuestCompletedTask } from './useGuestCompletedHistory';

export type InvoiceStatus = 'submitted' | 'approved' | 'rejected' | 'paid';

export interface InvoiceItem {
  id: string;
  invoiceId: string;
  completedTaskId?: string;
  description: string;
  workOrderNumber?: string;
  phase?: string;
  branch?: string;
  rolePerformed?: string;
  runtime?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  createdAt: string;
}

export interface Invoice {
  id: string;
  invoiceNumber: string;
  teamMemberId: string;
  teamMemberName?: string;
  status: InvoiceStatus;
  
  // Billing details
  billingName: string;
  billingAddress?: string;
  billingCity?: string;
  billingCountry?: string;
  billingTaxId?: string;
  billingBankName?: string;
  billingBankAccount?: string;
  billingBankRouting?: string;
  billingNotes?: string;
  
  // Payment terms
  invoiceDate: string;
  dueDate?: string;
  paymentInstructions?: string;
  
  // Totals
  subtotal: number;
  taxRate: number;
  taxAmount: number;
  totalAmount: number;
  currency: string;
  
  // Admin
  rejectionReason?: string;
  approvedById?: string;
  approvedAt?: string;
  assignedApproverId?: string;
  
  createdAt: string;
  updatedAt: string;
  
  // Items
  items?: InvoiceItem[];
}

export interface CreateInvoiceData {
  billingName: string;
  billingAddress?: string;
  billingCity?: string;
  billingCountry?: string;
  billingTaxId?: string;
  billingBankName?: string;
  billingBankAccount?: string;
  billingBankRouting?: string;
  billingNotes?: string;
  dueDate?: string;
  paymentInstructions?: string;
  taxRate?: number;
  assignedApproverId?: string;
  items: {
    completedTaskId?: string;
    description: string;
    workOrderNumber?: string;
    phase?: string;
    branch?: string;
    rolePerformed?: string;
    runtime?: string;
    quantity: number;
    unitPrice: number;
  }[];
}

// Hook to fetch billing users for approver dropdown
export function useBillingUsers() {
  return useQuery({
    queryKey: ['billing-users'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('team_member_roles')
        .select('team_member_id, team_members!inner(id, name, initials, color)')
        .eq('role_type', 'billing');

      if (error) throw error;
      return (data || []).map((r: any) => ({
        id: r.team_members.id,
        name: r.team_members.name,
        initials: r.team_members.initials,
        color: r.team_members.color,
      }));
    },
  });
}

// Guest hooks - view and manage own invoices
export function useMyInvoices() {
  const { data: currentMember } = useCurrentTeamMember();

  return useQuery({
    queryKey: ['my-invoices', currentMember?.id],
    queryFn: async (): Promise<Invoice[]> => {
      if (!currentMember?.id) return [];

      const { data, error } = await supabase
        .from('invoices')
        .select('*')
        .eq('team_member_id', currentMember.id)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return (data || []).map(mapInvoice);
    },
    enabled: !!currentMember?.id,
  });
}

export function useInvoice(invoiceId: string) {
  return useQuery({
    queryKey: ['invoice', invoiceId],
    queryFn: async (): Promise<Invoice | null> => {
      if (!invoiceId) return null;

      const { data: invoice, error } = await supabase
        .from('invoices')
        .select('*')
        .eq('id', invoiceId)
        .single();

      if (error) throw error;
      if (!invoice) return null;

      // Fetch items
      const { data: items, error: itemsError } = await supabase
        .from('invoice_items')
        .select('*')
        .eq('invoice_id', invoiceId)
        .order('created_at');

      if (itemsError) throw itemsError;

      return {
        ...mapInvoice(invoice),
        items: (items || []).map(mapInvoiceItem),
      };
    },
    enabled: !!invoiceId,
  });
}

// Create invoice - always submits immediately (no draft)
export function useCreateInvoice() {
  const queryClient = useQueryClient();
  const { data: currentMember } = useCurrentTeamMember();

  return useMutation({
    mutationFn: async (data: CreateInvoiceData) => {
      if (!currentMember?.id) throw new Error('Not authenticated');

      // Calculate totals
      const subtotal = data.items.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
      const taxRate = data.taxRate || 0;
      const taxAmount = subtotal * (taxRate / 100);
      const totalAmount = subtotal + taxAmount;

      // Create invoice - always submitted
      const { data: invoice, error } = await supabase
        .from('invoices')
        .insert({
          team_member_id: currentMember.id,
          invoice_number: '', // Will be generated by trigger
          status: 'submitted',
          billing_name: data.billingName,
          billing_address: data.billingAddress,
          billing_city: data.billingCity,
          billing_country: data.billingCountry,
          billing_tax_id: data.billingTaxId,
          billing_bank_name: data.billingBankName,
          billing_bank_account: data.billingBankAccount,
          billing_bank_routing: data.billingBankRouting,
          billing_notes: data.billingNotes,
          due_date: data.dueDate,
          payment_instructions: data.paymentInstructions,
          subtotal,
          tax_rate: taxRate,
          tax_amount: taxAmount,
          total_amount: totalAmount,
          assigned_approver_id: data.assignedApproverId || null,
        })
        .select()
        .single();

      if (error) throw error;

      // Create invoice items
      if (data.items.length > 0) {
        const itemsToInsert = data.items.map(item => ({
          invoice_id: invoice.id,
          completed_task_id: item.completedTaskId || null,
          description: item.description,
          work_order_number: item.workOrderNumber,
          phase: item.phase,
          branch: item.branch,
          role_performed: item.rolePerformed,
          runtime: item.runtime,
          quantity: item.quantity,
          unit_price: item.unitPrice,
          total_price: item.quantity * item.unitPrice,
        }));

        const { error: itemsError } = await supabase
          .from('invoice_items')
          .insert(itemsToInsert);

        if (itemsError) throw itemsError;
      }

      // Lock billing profile
      await supabase
        .from('billing_profiles')
        .update({ is_locked: true, locked_at: new Date().toISOString() })
        .eq('team_member_id', currentMember.id)
        .eq('is_locked', false);

      // --- Notify: PM, God users, Andrea Nieto, and chosen approver ---
      const invoiceData = invoice as any;
      const notifyIds = new Set<string>();

      // 1. All PMs and God users
      const { data: pmGodMembers } = await supabase
        .from('team_members')
        .select('id')
        .in('role', ['project_manager', 'god']);
      for (const m of pmGodMembers || []) notifyIds.add(m.id);

      // 2. Andrea Nieto (by name)
      const { data: andreaMembers } = await supabase
        .from('team_members')
        .select('id')
        .ilike('name', '%Andrea Nieto%');
      for (const m of andreaMembers || []) notifyIds.add(m.id);

      // 3. Chosen approver
      if (data.assignedApproverId) notifyIds.add(data.assignedApproverId);

      // Remove self from notifications
      notifyIds.delete(currentMember.id);

      for (const userId of notifyIds) {
        await supabase.rpc('create_notification', {
          p_user_id: userId,
          p_type: 'invoice_submitted',
          p_title: `Invoice ${invoiceData.invoice_number} Submitted`,
          p_message: `${currentMember.name || 'A vendor'} submitted an invoice ($${totalAmount.toFixed(2)}) for approval. invoice_id::${invoice.id}`,
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      // Send email with PDF (fire and forget)
      try {
        await supabase.functions.invoke('send-invoice-email', {
          body: { invoice_id: invoice.id },
        });
      } catch (emailErr) {
        console.error('Error calling send-invoice-email:', emailErr);
      }

      return invoice;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoiced-task-ids'] });
    },
  });
}

export function useDeleteInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      const { error } = await supabase
        .from('invoices')
        .delete()
        .eq('id', invoiceId);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

// Admin hooks - view all invoices and update status
export function useAllInvoices() {
  return useQuery({
    queryKey: ['all-invoices'],
    queryFn: async (): Promise<Invoice[]> => {
      const { data, error } = await supabase
        .from('invoices')
        .select(`
          *,
          team_members!invoices_team_member_id_fkey (name)
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return (data || []).map(row => ({
        ...mapInvoice(row),
        teamMemberName: (row as any).team_members?.name,
      }));
    },
  });
}

export function useApproveInvoice() {
  const queryClient = useQueryClient();
  const { data: currentMember } = useCurrentTeamMember();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      if (!currentMember?.id) throw new Error('Not authenticated');

      const { data, error } = await supabase
        .from('invoices')
        .update({
          status: 'approved',
          approved_by_id: currentMember.id,
          approved_at: new Date().toISOString(),
          rejection_reason: null,
        })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;

      const invoiceData = data as any;

      // Notify vendor
      if (invoiceData.team_member_id) {
        await supabase.rpc('create_notification', {
          p_user_id: invoiceData.team_member_id,
          p_type: 'invoice_approved',
          p_title: `Invoice ${invoiceData.invoice_number} Approved`,
          p_message: `Your invoice has been approved and is pending payment. invoice_id::${invoiceId}`,
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      // Notify users with 'payment' role that an invoice is ready for payment
      const { data: paymentMembers } = await supabase
        .from('team_member_roles')
        .select('team_member_id')
        .eq('role_type', 'payment');

      for (const pm of paymentMembers || []) {
        if (pm.team_member_id === currentMember.id) continue;
        await supabase.rpc('create_notification', {
          p_user_id: pm.team_member_id,
          p_type: 'invoice_approved',
          p_title: `Invoice ${invoiceData.invoice_number} Ready for Payment`,
          p_message: `Invoice from ${invoiceData.billing_name} ($${parseFloat(invoiceData.total_amount).toFixed(2)}) has been approved and needs payment. invoice_id::${invoiceId}`,
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      return data;
    },
    onSuccess: (_, invoiceId) => {
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

export function useRejectInvoice() {
  const queryClient = useQueryClient();
  const { data: currentMember } = useCurrentTeamMember();

  return useMutation({
    mutationFn: async ({ invoiceId, reason }: { invoiceId: string; reason: string }) => {
      if (!currentMember?.id) throw new Error('Not authenticated');

      const { data, error } = await supabase
        .from('invoices')
        .update({
          status: 'rejected',
          rejection_reason: reason,
        })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;

      const invoiceData = data as any;

      // Notify vendor that invoice was denied
      if (invoiceData.team_member_id) {
        await supabase.rpc('create_notification', {
          p_user_id: invoiceData.team_member_id,
          p_type: 'invoice_rejected',
          p_title: `Invoice ${invoiceData.invoice_number} Denied`,
          p_message: `Your invoice was denied. Reason: ${reason}. Please review and resubmit. invoice_id::${invoiceId}`,
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      return data;
    },
    onSuccess: (_, { invoiceId }) => {
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoiced-task-ids'] });
    },
  });
}

export function useMarkInvoicePaid() {
  const queryClient = useQueryClient();
  const { data: currentMember } = useCurrentTeamMember();

  return useMutation({
    mutationFn: async (invoiceId: string) => {
      if (!currentMember?.id) throw new Error('Not authenticated');

      const { data, error } = await supabase
        .from('invoices')
        .update({ status: 'paid' })
        .eq('id', invoiceId)
        .select()
        .single();

      if (error) throw error;

      const invoiceData = data as any;

      // Notify vendor
      if (invoiceData.team_member_id) {
        await supabase.rpc('create_notification', {
          p_user_id: invoiceData.team_member_id,
          p_type: 'invoice_paid',
          p_title: `Invoice ${invoiceData.invoice_number} Paid`,
          p_message: `Your invoice ($${parseFloat(invoiceData.total_amount).toFixed(2)}) has been marked as paid. invoice_id::${invoiceId}`,
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      // Notify Andrea Nieto
      const { data: andreaMembers } = await supabase
        .from('team_members')
        .select('id')
        .ilike('name', '%Andrea Nieto%');

      for (const andrea of andreaMembers || []) {
        if (andrea.id === currentMember.id) continue;
        await supabase.rpc('create_notification', {
          p_user_id: andrea.id,
          p_type: 'invoice_paid',
          p_title: `Invoice ${invoiceData.invoice_number} Paid`,
          p_message: `Invoice from ${invoiceData.billing_name} ($${parseFloat(invoiceData.total_amount).toFixed(2)}) has been marked as paid. invoice_id::${invoiceId}`,
          p_task_id: null,
          p_triggered_by_id: currentMember.id,
        });
      }

      // Send email notification for paid invoice (fire and forget)
      try {
        // Notify vendor via email
        await supabase.functions.invoke('send-notification-email', {
          body: {
            notification_id: crypto.randomUUID(),
            user_id: invoiceData.team_member_id,
            type: 'invoice_paid',
            task_id: null,
            triggered_by_id: currentMember.id,
            title: `Invoice ${invoiceData.invoice_number} Paid`,
            message: `Your invoice ($${parseFloat(invoiceData.total_amount).toFixed(2)}) has been marked as paid.`,
          },
        });

        // Notify Andrea via email
        for (const andrea of andreaMembers || []) {
          await supabase.functions.invoke('send-notification-email', {
            body: {
              notification_id: crypto.randomUUID(),
              user_id: andrea.id,
              type: 'invoice_paid',
              task_id: null,
              triggered_by_id: currentMember.id,
              title: `Invoice ${invoiceData.invoice_number} Paid`,
              message: `Invoice from ${invoiceData.billing_name} ($${parseFloat(invoiceData.total_amount).toFixed(2)}) has been marked as paid.`,
            },
          });
        }
      } catch (emailErr) {
        console.error('Error sending paid notification email:', emailErr);
      }

      return data;
    },
    onSuccess: (_, invoiceId) => {
      queryClient.invalidateQueries({ queryKey: ['all-invoices'] });
      queryClient.invalidateQueries({ queryKey: ['invoice', invoiceId] });
      queryClient.invalidateQueries({ queryKey: ['my-invoices'] });
    },
  });
}

// Helper functions
function mapInvoice(row: any): Invoice {
  return {
    id: row.id,
    invoiceNumber: row.invoice_number,
    teamMemberId: row.team_member_id,
    status: row.status,
    billingName: row.billing_name,
    billingAddress: row.billing_address,
    billingCity: row.billing_city,
    billingCountry: row.billing_country,
    billingTaxId: row.billing_tax_id,
    billingBankName: row.billing_bank_name,
    billingBankAccount: row.billing_bank_account,
    billingBankRouting: row.billing_bank_routing,
    billingNotes: row.billing_notes,
    invoiceDate: row.invoice_date,
    dueDate: row.due_date,
    paymentInstructions: row.payment_instructions,
    subtotal: parseFloat(row.subtotal) || 0,
    taxRate: parseFloat(row.tax_rate) || 0,
    taxAmount: parseFloat(row.tax_amount) || 0,
    totalAmount: parseFloat(row.total_amount) || 0,
    currency: row.currency || 'USD',
    rejectionReason: row.rejection_reason,
    approvedById: row.approved_by_id,
    approvedAt: row.approved_at,
    assignedApproverId: row.assigned_approver_id,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

function mapInvoiceItem(row: any): InvoiceItem {
  return {
    id: row.id,
    invoiceId: row.invoice_id,
    completedTaskId: row.completed_task_id,
    description: row.description,
    workOrderNumber: row.work_order_number,
    phase: row.phase,
    branch: row.branch,
    rolePerformed: row.role_performed,
    runtime: row.runtime,
    quantity: parseFloat(row.quantity) || 1,
    unitPrice: parseFloat(row.unit_price) || 0,
    totalPrice: parseFloat(row.total_price) || 0,
    createdAt: row.created_at,
  };
}

export function createItemsFromCompletedTasks(tasks: GuestCompletedTask[], defaultRate: number = 0): CreateInvoiceData['items'] {
  return tasks.map(task => ({
    completedTaskId: task.id,
    description: `${task.taskName}${task.tituloAprobadoEspanol ? ` - ${task.tituloAprobadoEspanol}` : ''}`,
    workOrderNumber: task.workOrderNumber,
    phase: task.phase,
    branch: task.branch,
    rolePerformed: task.rolePerformed,
    runtime: task.lockedRuntime,
    quantity: 1,
    unitPrice: defaultRate,
  }));
}
